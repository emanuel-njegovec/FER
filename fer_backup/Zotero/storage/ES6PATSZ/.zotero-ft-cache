This website utilizes technologies such as cookies to enable essential site functionality, as well as for analytics, personalization, and targeted advertising. You may change your settings at any time or accept the default settings. You may close this banner to continue with only essential cookies. Privacy Policy

Storage Preferences

Targeted Advertising
Personalization
Analytics
Save
Accept All
Reject All
Skip to Main Content
Browse
Books
Conferences
Courses
Journals & Magazines
Standards
Recently Published
Popular
My Settings
Alerts
My Research Projects
My Favorites
Remote Access
MyXplore
App
Preferences
Purchase History
Search History
What can I access?
Help
Contact Us
Resources and Help
More Sites
IEEE.ORG
IEEE XPLORE
IEEE-SA
IEEE SPECTRUM
MORE
Donate
Cart
Access provided by:
University of Zagreb
Sign Out
Attention Authors
ADVANCED SEARCH
Conferences >2022 IEEE 15th International ...
Avengers, Assemble! Survey of WebAssembly Security Solutions
Publisher: IEEE
Cite This
Minseo Kim; Hyerean Jang; Youngjoo Shin
View Document
9
Cites in
Papers
1698
Full
Text Views
Abstract
Authors
Figures
References
Citations
Keywords
Metrics
More Like This
 Download PDF
 Download References
 Request Permissions
 Save to
 Alerts
Abstract:
WebAssembly, abbreviated as Wasm, has emerged as a new paradigm in cloud-native developments owing to its promising properties. Native execution speed and fast startup ti...Show More
Metadata
 Contents
SECTION I.
Introduction

WebAssembly is a World Wide Web Consortium (W3C) open standard for a portable, efficient, and secure runtime of web applications. Abbreviated as Wasm, WebAssembly is essentially a sandboxed binary format that can be executed with different OSes on various hardware platforms with native execution speed [1]. Owing to many beneficial properties, the usage of Wasm is not limited to web applications, but is being extended to various applications such as desktop applications [2], mobile devices [3], IoT [4], [5], and embedded systems [6]. In particular, the versatility of WebAssembly brings huge benefits to cloud-native development platforms. Native execution speed and fast startup time of Wasm applications attracted many developers to consider Wasm as an alternative for container-based cloud applications [7]–​[9].

However, despite the isolation-based security by its design, Wasm has many security flaws and vulnerabilities that have prevented its rapid adoption in cloud computing. For instance, the native execution performance of Wasm applications tends to attract many cybercriminals and has thus resulted in the advent of Wasm-based resource-stealing malware (e.g., cryptomining malware [10]). The absence of proper defense techniques may result in massive financial losses for cloud users. Moreover, the design principle of Wasm, which supports type-unsafe languages such as C/C++, makes the Wasm binaries susceptible to a wide variety of memory bugs [11].

Thus, to enable the practical and secure usage of Wasm, it is necessary to conduct studies on the prevention of Wasm-based malware and the identification of vulnerabilities in Wasm binaries. Many researchers have previously attempted to address the various security concerns related to the use of Wasm, by applying memory and code protection mechanisms, and sandboxed environments. Consequently, various analysis techniques have been proposed to identify vulnerabilities in Wasm binaries and to protect Wasm applications from attacks. However, because Wasm is still a relatively new technology, the efforts to improve security remain inadequate. Moreover, to date, there is no reported survey of existing Wasm security techniques, which is necessary for developers and security researchers.

In this paper, we provide an in-depth and extensive survey of the state-of-the-art security techniques for Wasm binaries. In particular, we classify previous works based on their methodology and the target security concern. According to our criteria, previous studies on the security of Wasm can be categorized into two types, as security techniques that protect: (1) from malicious Wasm binaries, and (2) Wasm binaries from attacks. The first category mainly includes techniques to detect malicious Wasm binaries such as cryptojacking malware. The second category includes techniques to protect benign Wasm applications, as well as vulnerability analysis techniques. We analyze the strengths and weaknesses of each technique in comparison with other similar methods. Based on our analysis, we suggest a research direction for the security of Wasm binary as a cloud-native application. We expect our survey to contribute to the WebAssembly security research community applied to cloud environments. The contributions of our paper are as follows.

We present, to the best of our knowledge, the first in-depth and extensive survey of the state-of-the-art security techniques proposed in the literature for Wasm binaries.

We propose a novel taxonomy of Wasm binary protection mechanisms.

We present the results of quantitative and qualitative analyses of the strengths and weaknesses of each Wasm security technique compared with other similar techniques.

We present a discussion of the open problems in current Wasm binary security enhancement research and provide some suggestions to improve security.

Figure 1.

Compilation process of WebAssembly binary

The paper is structured as follows. Section II provides an overview of the Wasm binary and describes its structure and basic security mechanisms. Section III describes the usage of Wasm binaries and the associated vulnerabilities in Wasm compilers. Section IV introduces Wasm binary protection methods. Section V describes the weaknesses of existing Wasm binary protection methods and discusses future research directions. Lastly, Section VI presents the conclusions.

SECTION II.
Background on Wasm

In this section, we provide some essential background information on Wasm. Specifically, we preset an overview of Wasm by describing the structure of Wasm and its built-in security mechanism.

A. Brief overview

The evolution of web browsers has been obstructed by computationally inefficient JavaScript language. Furthermore, as JavaScript can directly access the Document Object Model (DOM), it has a vulnerability that can threaten normal users if an attacker identifies an accessible path to the DOM. To overcome these obstacles, in 2013, Mozilla introduced asm.js [12] as an extension of JavaScript designed to boost execution performance. As an alternative to asm.js, Wasm has been proposed as a new standard by the W3C. Wasm is a portable, low-level bytecode and compilation target designed for safe and fast execution on various target platforms such as x86 and ARM (See Fig. 1). Wasm supports high-level languages such as C/C++ [13] and Rust [14] and currently, efforts are being undertaken to extend the support to Python [15] and C# [16]. Because a Wasm compilation produces a compact binary, the process of downloading and executing the Wasm binary on the web is less computationally expensive than that sourced from JavaScript code.

B. Structure of Wasm module

Wasm modules are created as a result of a Wasm compilation process. As shown in Fig. 2, the Wasm module generally consists of Preamble, Standard, and Custom sections, the details of which are presented below.

Figure 2.

Structure of WebAssembly module

1) Preamble:

This is a section that indicates a starting point for the Wasm bytecode. More specifically, it informs that the binary file is a Wasm module and also includes additional information such as the Wasm version.

2) Standard section:

This section contains all the necessary information for executing a Wasm module, such as the code, function, and memory. Every Wasm module has at least one Standard section, and they each validate their Standard sections before initiating the execution. Each value in the Standard section appears only once in the order shown in Fig. 2.

Type. The Type section declares a list of all the unique function signatures used by the Wasm module, including the imported functions. Additionally, multiple functions may share the same function signature. Fig. 2 shows an example of the Type section in which three function signatures are declared.

Import. The Import section declares all the functions, tables, memory, and global variables imported by the Wasm module. This section is necessary to enable code and data sharing among multiple modules.

Function. The Function section contains a complete list of the functions defined in the Wasm module. The location of a function in the module is referenced with a function body index in the Code section; the value is applied as an index of the function signature in the Type section.

Table. The Table section provides an indirection to refer to the actual function. That is, the function call occurs through this table mapping. This sections enhance the security of Wasm module by preventing code from directly accessing function pointers.

Figure 3.

An example of linear memory in a Wasm module

Memory. The Memory section contains the linear memories that are used by a module instance. As with the Table section, it is a key element of Wasm security, as the Memory section prohibits Wasm binaries from directly accessing memory.

Code. The Code section contains the body of functions defined in the Wasm module. The order of functions in the Code section is the same as the order in which the function signatures are declared.

3) Custom section:

The Custom section typically contains arbitrary Wasm module data, such as the symbols for function and variable names, which are necessary for debugging. Unlike other user-defined sections, the Custom section only appears after the Standard section. However, the Custom section can appear more than once in a Wasm module and those sections can share the same name. Unlike Standard sections, this section does not introduce error, even if it is not correctly placed.

C. Security features of Wasm

Security is one of the primary design goals for Wasm. Thus, Wasm is designed to have the following security features and properties.

1) Sandboxed environment:

Wasm binaries run in a sand-boxed environment that is isolated from the outside. Thus, by design, a Wasm module cannot operate outside of the confines of the sandbox without authorized permission and proper APIs. For instance, Wasm modules in a web browser have no direct access to DOM objects, as they are only allowed access via JavaScript APIs. Wasm modules are also subject to restrictions on information flow through the same-origin policy (SOP) enforced by web browsers. Additionally, a standalone Wasm that runs on a sandboxed runtime with OS support, is also requested to use propose APIs to access system resources such as files and sockets.

2) Linear memory:

A Wasm module is instantiated, as it uses a specific API to create necessary memory objects for the execution. Then, a JavaScript engine or system runtime internally creates a managed buffer (e.g., an ArrayBuffer for JavaScript). Thus, the Wasm module operates by accessing the physical memory address indirectly. This means that the linear memory of Wasm is implemented in managed buffers to ensure that the Wasm module only reads and writes data in a limited area of the memory.

As shown in Fig. 3, the Wasm module does not have direct access to the instruction address. For example, if the Wasm module invokes a function located at 0x8F00A1B9, it can only access the function through the function table. However, the data located at 0x901AFA12 in the linear memory can be directly accessed by the Wasm module.

3) Control-flow integrity:

In Wasm, the control-flow integrity for direct/indirect function calls and returns are guaranteed at runtime. To enable this, the compiler creates a control-flow graph (CFG) for the Wasm program during a compilation process. Thus, any executions that do not follow the CFG would result in failure.

When calling a function directly from the Wasm module, Wasm explicitly uses the function’s index to protect the binary so that the function is called normally. Specifically, the functions are indexed in a function table with type information and the type is validated whenever direct function calls are made. Alternatively, returns are protected through a protected call stack.

SECTION III.
Related Work

In this section, we discuss some previous related work.

A. Surveys on the usage of Wasm

Owing to its portability, Wasm is currently being extended from web applications to desktop, mobile, IoT, and even cloud applications. However, the knowledge on the usage of programming languages in the Wasm ecosystem is minimal. In consideration of this, Hilbig et al. [10] surveyed the usage of Wasm languages in the wild; they discovered that approximately 64.2% of Wasm binaries were compiled from C/C++ source code. The difference between our survey and that conducted by Hilbig et al. [10] is that they mainly focused on investigating the practical usage of Wasm binaries, whereas we attempted to survey the state-of-the-art security enhancement techniques for Wasm binaries.

B. Studies on Wasm vulnerabilities

Although the developers of Wasm did consider security in the design, it is known that Wasm has many security flaws, including traditional buffer overflow vulnerabilities [11].

Romano et al. [17] discovered that the vulnerabilities in Wasm binaries are primarily sourced from the lack of any protections or security mechanisms in most Wasm compilers. They analyzed some Wasm compilers such as Emscripten [13], AssemblyScript [18], and Rustc/Wasm-Bindgen [19], to identify their vulnerabilities and flaws. They consequently found bugs in Emscripten that may cause significant security problems [17]. They also investigated the compatibility-related problems of programming languages, because Wasm tends to have more limited data types (e.g., i32, f32, i64, and f64) than other languages; this may lead to type-confusion vulnerabilities.

To summarize, the work of Romano et al. [17] focused on investigating various problems with Wasm compilers, including several vulnerabilities that may originate from compiler errors. Our work is different because we focus on security concerns in Wasm binaries, not in compilers. Furthermore, we also surveyed various security enhancement techniques for Wasm binaries.

Figure 4.

Classification of security techniques for WebAssembly binaries

SECTION IV.
Security techniques for Wasm binaries

In this section, we present the results of our detailed survey of the state-of-the-art security techniques for Wasm binaries. Generally, the security techniques proposed in the literature can be classified according to their security goals and methodologies. Thus, we have classified previous works into two categories according to the criteria, as security techniques to: (1) provide protection from malicious Wasm binaries (details presented in Section IV-A), and (2) protect Wasm binaries from various attacks (details presented in Section IV-B). Fig. 4 shows our taxonomy of the Wasm security solutions.

The most recent work that we surveyed tended to address security problems by constructing attack detection or vulnerability analysis methods. These methods share several general approaches, which have been classified as either static-, dynamic-, or hybrid-based.

For our survey, the surveyed methods were placed in the static-based approach category if their primary strategy was based on the analysis of binary files or source code of Wasm modules. Such methods were developed to identify vulnerabilities or detect malicious code inside Wasm applications by conducting static analysis techniques, such as formal verification and reverse engineering.

The surveyed methods were placed in the dynamic-based approach category if their strategy was primarily based on monitoring the dynamic behavior of Wasm binaries. The dynamic behavior may include changes to the input/output, environment variables, and/or running states of the program. Any changes in behavior during the execution of a Wasm binary can be traced by using debuggers or dynamic binary instrumentation tools.

Lastly, the surveyed methods were placed in the hybrid-based approach category if they used both static- and dynamic-based approaches to achieve their goals.

A. System protection from malicious Wasm binaries

Among the various security techniques that have been proposed to date for detecting malicious Wasm binaries, most focus on the detection or identification of a type of resource-stealing malware (e.g., cryptojacking malware). In this section, we present the results of our survey of such protection schemes against malicious Wasm binaries. Specifically, we have classified them as static-, dynamic-, or hybrid-based approaches. We also present the analysis of the detection performance of these schemes.

Static analysis-based approach. MINOS [20] is a malware detection method that has been specifically designed for the detection of Wasm-based cryptojacking malware. In general, the MINOS malware detection scheme converts a binary file of a Wasm module into a grayscale image. MINOS applies the converted image as an input to a convolutional neural network (CNN) to decide whether the Wasm binary performs a cryptojacking attack. Because the analysis is performed on a static basis, MINOS does not subject the production systems to high computational overhead.

Table I Classification of scheme to protect systems from malicious WebAssembly binary

MinerRay [21] attempted to detect the cryptojacking behavior of a Wasm module by analyzing a CFG. More specifically, MinerRay constructs a CFG from the Wasm binary and then searches for control flows to certain encryption algorithms that are commonly used for cryptojacking. In the case of Wasm-based cryptojacking malware, the cryptographic algorithms are typically implemented in JavaScript, Wasm, and/or nonstandard Wasm libraries such as asm.js. First, MinerRay converts JavaScript and non-standard libraries into standard Wasm binaries. Then, it translates the standard Wasm binary into an intermediate representation from which an interprocedural CFG is constructed. In an experimental environment, MinerRay achieved high detection rates for most cryptojacking Wasm binaries that run on web browsers; it has also been demonstrated to have the lowest false positive rate among all relevant detection schemes in existence at the time.

MineSweeper [22] is another detection method for cryptojacking Wasm binaries. Essentially, the detection strategy of MineSweeper is dependent on the characteristics of CryptoNight [29], which is a specialized algorithm designed for cryptomining. Specifically, MineSweeper attempts to identify cryptojacking attacks by identifying the signatures of the CryptoNight algorithm and its variants in Wasm binaries.

All the abovementioned static analysis-based approaches have the advantage of a low system overhead. This is because Wasm module execution is not required for the detection techniques to be applied to the binary files. However, static approaches have a critical drawback in that they can be easily bypassed by attackers utilizing code obfuscation techniques.

Dynamic analysis-based approach. RAPID [23] is a dynamic analysis-based scheme that identifies cryptojacking attacks. RAPID uses JavaScript API calls and system resources to monitor the behavior of suspected applications during runtime. To this end, information on JavaScript API usage is collected from web browsers by using Chromium2 and Chrome debugging features. The runtime usage of memory, CPU, and network transmission of the web browser is also collected by using Docker containers. Then, a support vector machine is employed to allow this raw data to be applied as the basis of a classification model. Because the classification-enabling features are obtained with the aid of resource-monitoring tools, RAPID is likely to be bypassed by attackers who can disturb system resource monitoring.

To overcome the limitation of RAPID, Bian et al. [24] proposed an approach that applies the instruction stream of a Wasm application as a feature. The effectiveness of their scheme was predicated upon the fact that the instruction sequence of cryptojacking malware is distinguishable from benign Wasm binaries. Specifically, cryptojacking malware performs a considerably large number of hash computations that make the instruction sequences uniform. The results of evaluation revealed that the scheme proposed by Bian et al. afforded higher cryptojacking attack detection accuracy than previously developed schemes.

CoinSpy [25] attempts to identify cryptojacking attacks by exploiting the fact that proof-of-work (PoW) algorithms are common in cryptojacking malware. In particular, the CoinSpy approach was established based on the results of previous observations that indicated that the number of parallel threads and memory usage substantially increase while the PoW algorithm is running. The CoinSpy detection method was also predicated upon previous observations that have indicated that communication from the malware only occurs when the CPU is in an idle state. With these features as its basis, a CNN-based classification model was built to detect cryptojacking attacks.

MineThrottle [26] is predicated upon previous observations that indicate that the frequency distribution of cryptojacking malware instructions is unique and distinguishable from that of normal applications. Accordingly, an attack is judged to occur if the frequency of specific instructions is abnormal or far from the threshold. As attackers may bypass the detection by using some dummy instructions, MineThrottle was also designed to include a feature that prevented detection circumvention through the implementation of dynamic thresholds that were specific to each attack case. The results of evaluation revealed that MineThrottle had a high attack detection accuracy and low false-positive rate.

Outguard [27] attempts to detect cryptojacking attacks based on the characteristics of Wasm binary execution. In particular, this method analyzes all the functions in a JavaScript runtime and rendering engine to accurately extract the behavioral characteristics of cryptomining. The results of analysis revealed that functions related to the web worker, parallel operation, Wasm, WebSockets, the hash algorithm, PostMessage event loading, and message loop event loading, were important as signatures for attack detection.

To summarize, all the abovementioned dynamic analysis-based methods apply the behavioral characteristics of Wasm binaries as the basis of their attack detection schemes. Thus, this type of approach is more difficult for attackers to bypass than the static-based approach. However, this type of approach has the following limitation: the detection can only be performed when the suspected binary is being executed; therefore, this type of approach may have a higher computational overhead.

Hybrid analysis-based approach. As an attempt to overcome the limitations of static and dynamic analysis-based approaches, certain methods have been designed to incorporate both types of approaches to achieve high-accuracy and efficient attack detection. SEISMIC [28] is a detection method that adopts such a hybrid analysis-based approach. SEISMIC first converts a Wasm binary into Wasm text format (WAT) that is subsequently parsed into an abstract syntax tree form. Then, it inserts a new global 64-bit integer variable into global sections of the Wasm binary to profile the Wasm instructions. This allows SEISMIC to monitor all the Wasm binary instructions that are executed during runtime. The results of the evaluation of SEISMIC revealed that the hybrid analysis-based approach has the following advantage: higher accuracy can be obtained even under the conditions of a small set of features.

Comparative analysis. We now present our comparative analysis of the static-, dynamic-, and hybrid-based methods presented in this section. The results of analysis are summarized in Table I.

Dataset. We first investigated the types of datasets used in the surveyed works to evaluate the performance of their approaches. As shown in Table I, the investigation revealed that the dataset from the Alexa site [30] was employed for most studies; this means that the real Wasm binaries applied for the evaluation were mostly collected from websites in the wild. Because Wasm is currently being extended for applications beyond the web, including the cloud, we were able to determine that the datasets used in the surveyed works did not cover all the Wasm use cases.

Performance. We compared the performances of the surveyed methods in terms of the attack detection time, accuracy, and F1 score. The comparison was based on the results of evaluation for each scheme. The results of this performance comparison are also presented in Table I. The table shows that the scheme developed by Bian et al. [24] has a relatively high detection accuracy and F1 score compared with those of other schemes. We attribute this to their evaluation methodology; specifically, the number of datasets that were applied for the evaluation was relatively small.

Cryptomining algorithms. We also investigated the detection coverage of the surveyed methods. Because the primary goal of all the schemes was to identify cryptojacking attacks in Wasm binaries, we compared the coverage with respect to a set of commonly used cryptomining tools such as CoinHive, CryptoNight, and CryptoLoot [31]. As can be seen in Table I, we found that almost all the schemes can detect malicious Wasm binaries that employ those cryptomining tools. In addition, certain techniques can detect a wider variety of cryptomining algorithms.

B. Hardening the security of Wasm binaries

In addition to enlightening a research direction for Wasm-based malware detection, there have been efforts dedicated to hardening the security of Wasm binaries from the perspectives of (1) vulnerability analysis and (2) protection from attacks. In this subsection, we present the in-depth results of a survey of such schemes, as well as a comparative analysis.

1) Vulnerability analysis of Wasm binaries:

Because Wasm was designed to be a polyglot compilation target, it supports multiple programming languages, including type-unsafe languages such as C/C++. Given this fact, Wasm binaries compiled from unsafe languages may contain memory corruption vulnerabilities that make them susceptible to classical buffer overflow attacks [11]. Such vulnerable Wasm binaries become attractive targets as they are easily exploited by attackers. Thus, vulnerability analysis techniques for Wasm binaries are necessary to reinforce Wasm security. In the literature, there are a number of papers that describe a method of analysis to identify vulnerabilities in Wasm binaries. Table II lists the binary analysis techniques that we have classified according to their methodology, i.e., static analysis-, dynamic analysis-, and hybrid analysis-based approaches.

Table II Classification of WebAssembly binary vulnerability analysis scheme

Static analysis-based approach. Szanto et al. [32] proposed a static analysis-based vulnerability detection method that inserts a taint into the program’s memory, then tracks this data and observes the impact of that value on the program. In this method, the input parameters of the functions in the Wasm binary are applied as taint labels. With this method, Wasm binaries can be analyzed without modifying the structure.

Alternatively, Wasmati [33] identifies vulnerabilities in a Wasm binary by constructing a code property graph (CPG) from the binary file. In this method, the execution order, execution path, dependency of the data, and control flows of the Wasm binary, are all expressed in the CPG. The experimental results reported in the paper revealed that Wasmati was able to detect all vulnerabilities included in binaries written in C/C++ language. Moreover, Wasmati was also demonstrated to be able to find vulnerabilities in the interface between a Wasm binary and JavaScript.

Wassail [34] is the first static analysis-based method to utilize a compositional analysis technique [39] to find vulnerabilities in a Wasm binary. Compositional analysis techniques are techniques that infer knowledge about an entire system based on an analysis of partial components of the system. In the case of Wasm, all functions within a Wasm binary are isolated and only accessible via JavaScript. This characteristic hinders vulnerability analysis because it is difficult to determine the entire analysis scope affected by interesting functions. Wassail is able to overcome this type of challenging problem by integrating a compositional analysis technique into a method of summary-based configuration analysis.

Static analysis-based approaches have an advantage as vulnerabilities can be identified in the software development stage. However, its drawback is that the dynamic behavior of a program is invisible; thus, it cannot detect vulnerabilities that only occur in certain control flows.

Dynamic analysis-based approach. TaintAssembly [35] is a dynamic analysis-based method that utilizes a taint analysis technique to detect vulnerabilities in Wasm binaries. In TaintAssembly, all Wasm variables of type i32, i64, f32, and f64 are labeled as tainted inputs. The results of their evaluation revealed that all the vulnerabilities in a Wasm binary can be detected with an acceptable computational overhead. Nonetheless, a limitation of TaintAssembly is that the structure of the Wasm binary needs to be reconstructed before the taint labels can be set for all the variables in the program.

Fuzzm [36] constitutes the first method to utilize greybox fuzzing to detect vulnerabilities in Wasm binaries. In addition, Fuzzm applies a canary-based protection mechanism that isolates the Wasm binary from memory corruption vulnerabilities such as stack and heap overflow.

WAFL [37] is a Wasm binary-only fuzzing technique that utilizes an AFL++ fuzzer [40]. More specifically, WAFL applies coverage-based fuzzing to the Wasm binary with better performance; this is possible because running instances can be quickly reset by using VM snapshots. WAFL is not only applicable to Wasm binaries running on a web browser but it is also applicable to standalone binaries with a Wasm system interface [41].

As previously mentioned, dynamic analysis-based methods can only be implemented under the conditions of program execution. This implies that vulnerability analysis can only be performed within the context of a running process; this may limit the applicability of dynamic-based approaches.

Hybrid analysis-based approach. Wasabi [38] is a hybrid analysis-based framework for vulnerability analysis in Wasm. The first step of this method involves modifying a bytecode of the Wasm binary to perform binary instrumentation. After the binary has been instrumented, Wasabi monitors the dynamic behavior of the Wasm module on an instruction-by-instruction basis.

Comparative analysis. We conducted comparative analysis on the vulnerability analysis techniques presented in this subsection based on their implementation method and runtime overhead. The results of comparison are summarized in Table II.

Implementation. Most works discussed in this subsection also introduced tools that implement the proposed vulnerability analysis techniques. Most of these tools were implemented by the corresponding authors and have been made public under open-source licenses (See Table II). An exception is that, in the case of TaintAssembly [35], the proposed technique is implemented by modifying a JavaScript engine.

Runtime overhead. We evaluated the performance of the surveyed techniques in terms of their runtime overhead. Note that the results of our analysis are based on the results of the evaluations that are available in the original papers. Table II lists the runtime overhead of each vulnerability analysis technique.

2) Protection from attacks:

The types of attacks targeting Wasm binaries continue to increase in number because Wasm applications are widely applied in various environments other than web browsers. Thus, in this section, we introduce several techniques to protect Wasm from such attacks.

Ensuring constant-time programming. Wasm applications have become attractive targets for attackers who possess the ability to mount side-channel attacks [50]. To mitigate such attacks, several techniques that employ a constant-time programming approach have been proposed to reinforce the security of Wasm binaries. Constant-time programming is an approach that establishes a software-based defense mechanism to protect against side-channel attacks. It restricts secret-dependent control flow and memory operations in a program. There are several reports on the application of constant-time programming to Wasm binaries.

For example, Vivienne [42] is a verification scheme that checks whether a Wasm binary adheres to the constant-time principle. It applies relational symbolic execution for verification. More specifically, it performs verification by first passing the input values that include the same public values and different secret values, to two instances of programs; then, it evaluates the relational symbol execution result. If the two instances output the same result, then it verifies that the program adheres to the constant-time principle.

CT-Wasm [43] is a method that enhances the security of Wasm language such that it can be safely applied to cryptographic implementations. Specifically, Wasm has been reinforced by strictly restricting the flow of security information [51] under the constant-time programming principle [52]. This allows Wasm binaries to be protected from various timing attacks.

Protection from microarchitectural attacks. Recently, several studies on Wasm protection against microarchitectural attacks have been conducted.

Swivel [44] is a compiler-based protection method that provides protection against microarchitectural attacks that exploit conditional branch predictors, branch target buffers, and return stack buffers. Swivel comprises two implementations, i.e., Swivel software-based fault isolation (Swivel-SFI) and Swivel control-flow enforcement technology (Swivel-CET). Swivel-SFI lays out the basic blocks as linear blocks and each linear block secures against speculative execution. Then, it protects the backward edge by replacing the return instructions and using a separate return stack. Alternatively, Swivel-CET employs a hardware shadow stack to protect Wasm binaries.

Lurking Eyes [45] attempts to protect Wasm modules based on information about known cache side-channel vulnerabilities. In particular, it extracts JavaScript code from HTML data and determines whether the code snippet contains the same characteristics of the known vulnerabilities.

CROW [46] employs a code diversification approach to protect Wasm binaries from cache side-channel attacks. Specifically, it creates various binaries that have different execution flows and variables for the same application. The diversity of the Wasm binary hinders the ability of attackers to deliver cache side-channel attacks.

Protection from software attacks. Because Wasm applications are generally susceptible to a variety of software attacks, defense methods have also been devised to protect Wasm binaries from software-level attacks.

MS-Wasm [47] is a defense method that entails the use of dedicated hardware to ensure Wasm memory security. Specifically, this technique protects the memory in a Wasm module from attacks by restricting the access between the Wasm memory and other segments.

SELWasm [48] is a defense method that protects the execution code in a Wasm module by encrypting the code with cryptographic algorithms.

VeriWasm [49] is a verification method that validates the isolation of the memory in Wasm binary. It utilizes a static software-based fault-isolation verification technique that verifies the security of Wasm modules during compile time. In particular, VeriWasm creates a CFG based on the compiled Wasm binary and then analyzes the safety properties of each function to determine if the module is safe.

Comparative analysis. Here, we discuss the results of our comparative analysis of Wasm binary protection schemes. Note that we focused on comparing the primary protection approach and implementation method of the surveyed schemes. The results of our comparative analysis are summarized in Table III.

Protection approach. Regarding the protection approaches, there are two general approaches to ensuring the security of Wasm. The first approach involves hardening the Wasm binaries to eliminate internal vulnerabilities. The second approach involves the real time and accurate detection of active attacks on Wasm modules. We have categorized various protection schemes based on these criteria, as can be seen in Table III.

Implementation method. The results of our analysis revealed that most of the works presented in this subsection entail the application of custom-made tools to implement the proposed techniques; these tools have been made public under open-source licenses. Thus, these protection techniques can be easily applied to Wasm applications without any restrictions.

Table III Classification of WebAssembly binary protection schemes from attacks
SECTION V.
Open problems

In this section, we describe the limitations of existing Wasm binary protection methods and suggest future research directions.

A. Protection from malicious Wasm binaries

The surveyed schemes that are designed to protect against malicious Wasm applications has some limitations. In particular, the data set for evaluating the proposed approach is limited to specific algorithms used in cryptojacking attacks. This may cause difficulty in detecting attacks implemented with other algorithms. Thus, more extensive data sets should be used for the performance evaluation.

Furthermore, these schemes may be easily bypassed by code obfuscation techniques. Given that there are existing code obfuscation techniques for Wasm, such as Wobfuscator [53], it is necessary to develop techniques to detect malicious Wasm even if a code obfuscation technique is applied.

B. Hardening the security of Wasm binaries
1) Wasm binary vulnerability analysis:

It is important to identify internal Wasm binary vulnerabilities before it is deployed to users. In particular, the most frequently compiled languages for Wasm binaries are C/C++, so it is necessary to check for vulnerabilities in advance. However, to date, there have been no investigations into internal Wasm binary vulnerability detection methods.

Static analysis-based methods utilize a taint analysis technique to identify internal Wasm binary vulnerabilities when the program is not being executed. However, its drawback is that its range of detection is limited to the range affected by the input value.

Alternatively, dynamic analysis-based methods use fuzzing to analyze Wasm binaries. However, current fuzzing techniques are only available for Wasm binaries compiled from C/C++. Thus, its limitation is that it is not possible to analyze the vulnerabilities in Wasm binaries compiled from other programming languages such as Rust or Python.

In addition, current research on Wasm binary vulnerability analysis tends to be biased toward web applications. Given that Wasm is currently being extended to various applications, it is necessary to correspondingly extend the research on Wasm vulnerability analysis.

2) Protecting Wasm binaries from attacks:

As attacks against Wasm binaries continue to increase, some researchers have opted to focus on hardening the security of Wasm binaries.

Most of the existing techniques focus on Wasm binaries used in web environments. However, Wasm is currently being extended for application as an alternative for containers; this means that it is increasingly being employed as a standalone platform. Thus, research on attacks and countermeasures against Wasm applications used in various environments should be preceded.

SECTION VI.
Conclusion

Wasm is beginning to be widely adopted in cloud computing, as it offers the promise of a high execution performance with better security. However, research to extend the applicability of Wasm to cloud computing is still in its early stage. Thus, security concerns related to the application of Wasm in a cloud environment have not been extensively investigated.

In this paper, we surveyed existing state-of-the-art techniques and solutions related to the security of Wasm binaries. We constructed a new taxonomy of Wasm security solutions and applied it to classify all the techniques proposed in the literature. We also discussed the results of qualitative and quantitative comparative analyses of these techniques. Moreover, we discussed the limitations of the current protection techniques and suggested future research directions. In particular, we discussed future research directions to enhance the security of Wasm binaries in cloud-native applications. We believe that our survey constitutes a significant contribution to research on strengthening the security of Wasm binaries.

ACKNOWLEDGEMENT

This research was supported by the National Research Foundation of Korea(NRF) grant funded by the Korea government(MSIT) (No.2020R1F1A1065539)

More Like This
An investigation of security risk & taxonomy of Cloud Computing environment

2021 2nd International Conference on Smart Electronics and Communication (ICOSEC)

Published: 2021

Cloud Computing security classifications and taxonomies: a comprehensive study and comparison

2020 5th International Conference on Cloud Computing and Artificial Intelligence: Technologies and Applications (CloudTech)

Published: 2020

Show More
IEEE Personal Account
CHANGE USERNAME/PASSWORD
Purchase Details
PAYMENT OPTIONS
VIEW PURCHASED DOCUMENTS
Profile Information
COMMUNICATIONS PREFERENCES
PROFESSION AND EDUCATION
TECHNICAL INTERESTS
Need Help?
US & CANADA: +1 800 678 4333
WORLDWIDE: +1 732 981 0060
CONTACT & SUPPORT
Follow

About IEEE Xplore | Contact Us | Help | Accessibility | Terms of Use | Nondiscrimination Policy | IEEE Ethics Reporting | Sitemap | IEEE Privacy Policy

A public charity, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.

© Copyright 2025 IEEE - All rights reserved, including rights for text and data mining and training of artificial intelligence and similar technologies.