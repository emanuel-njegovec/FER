
@inproceedings{haas_bringing_2017,
	address = {Barcelona Spain},
	title = {Bringing the web up to speed with {WebAssembly}},
	isbn = {978-1-4503-4988-8},
	url = {https://dl.acm.org/doi/10.1145/3062341.3062363},
	doi = {10.1145/3062341.3062363},
	abstract = {The maturation of the Web platform has given rise to sophisticated and demanding Web applications such as interactive 3D visualization, audio and video software, and games. With that, efÔ¨Åciency and security of code on the Web has become more important than ever. Yet JavaScript as the only builtin language of the Web is not well-equipped to meet these requirements, especially as a compilation target.},
	language = {en},
	urldate = {2025-01-18},
	booktitle = {Proceedings of the 38th {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {ACM},
	author = {Haas, Andreas and Rossberg, Andreas and Schuff, Derek L. and Titzer, Ben L. and Holman, Michael and Gohman, Dan and Wagner, Luke and Zakai, Alon and Bastien, Jf},
	month = jun,
	year = {2017},
	pages = {185--200},
	file = {PDF:/home/emanuel/Zotero/storage/26XW96HH/Haas et al. - 2017 - Bringing the web up to speed with WebAssembly.pdf:application/pdf},
}

@inproceedings{spies_evaluation_2021,
	title = {An {Evaluation} of {WebAssembly} in {Non}-{Web} {Environments}},
	url = {https://ieeexplore.ieee.org/document/9640153/?arnumber=9640153},
	doi = {10.1109/CLEI53233.2021.9640153},
	abstract = {In 2017, WebAssembly, a portable low-level byte-code, was released by the four major web browser makers to address the challenges presented by the maturation of the web and the rise of sophisticated and interactive applications such as 3D visualization, audio, and video streaming, and online games. JavaScript heretofore was the only built-in language of the web, and unfortunately, it is not well outfitted for the rich applications that have come to dominate the web today. Since its initial release, WebAssembly has made great strides on the web. With the WebAssembly System Interface release in March 2018, which allows WebAssembly to communicate with the operating system, it has become possible to run WebAssembly applications outside web browsers. This paper reviews the current state of WebAssembly and its system interface, describes the costs and benefits of these technologies for applications in different environments, and evaluates performance and portability. Our performance measurements demonstrate that WebAssembly is generally faster than JavaScript and, in some cases, can approach native code performance. Despite its limitations which make WebAssembly useless for specific applications domains, it nevertheless, has the potential to be beneficial in many environments and is likely to grow further even outside its original web environment.},
	urldate = {2025-01-18},
	booktitle = {2021 {XLVII} {Latin} {American} {Computing} {Conference} ({CLEI})},
	author = {Spies, Benedikt and Mock, Markus},
	month = oct,
	year = {2021},
	keywords = {asm.js, bytecode, Codes, Costs, Games, JavaScript, Measurement, Operating systems, Three-dimensional displays, Visualization, WebAssembly},
	pages = {1--10},
	file = {Full Text PDF:/home/emanuel/Zotero/storage/T23VRAGG/Spies and Mock - 2021 - An Evaluation of WebAssembly in Non-Web Environments.pdf:application/pdf;IEEE Xplore Abstract Record:/home/emanuel/Zotero/storage/MC4WUFT4/9640153.html:text/html},
}

@inproceedings{wang_empowering_2021,
	title = {Empowering {Web} {Applications} with {WebAssembly}: {Are} {We} {There} {Yet}?},
	shorttitle = {Empowering {Web} {Applications} with {WebAssembly}},
	url = {https://ieeexplore.ieee.org/document/9678831/?arnumber=9678831},
	doi = {10.1109/ASE51524.2021.9678831},
	abstract = {WebAssembly is the newest web standard. It defines a compact bytecode format that allows it to be loaded and executed fast. While WebAssembly is generally believed to be faster than JavaScript, there have been inconsistent results when it comes to showing which code is faster. Unfortunately, insufficient study has been conducted to understand the performance benefits of WebAssembly. In this paper, we investigate how browser engines optimize WebAssembly execution in comparison to JavaScript. In particular, we measure their execution time and memory usage with diverse programs. Our results show that (1) JIT optimization in Chrome significantly impacts JavaScript speed but has no discernible effect on WebAssembly speed; (2) WebAssembly uses much more memory than JavaScript. We hope that our findings can help WebAssembly virtual machine developers uncover optimization opportunities.},
	urldate = {2025-01-18},
	booktitle = {2021 36th {IEEE}/{ACM} {International} {Conference} on {Automated} {Software} {Engineering} ({ASE})},
	author = {Wang, Weihang},
	month = nov,
	year = {2021},
	note = {ISSN: 2643-1572},
	keywords = {Codes, Atmospheric measurements, Browsers, Optimization, Particle measurements, Time measurement, Virtual machining},
	pages = {1301--1305},
	file = {Full Text PDF:/home/emanuel/Zotero/storage/P435HIL2/Wang - 2021 - Empowering Web Applications with WebAssembly Are We There Yet.pdf:application/pdf;IEEE Xplore Abstract Record:/home/emanuel/Zotero/storage/GFBTYH3G/9678831.html:text/html},
}

@inproceedings{watt_mechanising_2018,
	address = {Los Angeles CA USA},
	title = {Mechanising and verifying the {WebAssembly} specification},
	isbn = {978-1-4503-5586-5},
	url = {https://dl.acm.org/doi/10.1145/3167082},
	doi = {10.1145/3167082},
	language = {en},
	urldate = {2025-01-18},
	booktitle = {Proceedings of the 7th {ACM} {SIGPLAN} {International} {Conference} on {Certified} {Programs} and {Proofs}},
	publisher = {ACM},
	author = {Watt, Conrad},
	month = jan,
	year = {2018},
	pages = {53--65},
	file = {Full Text:/home/emanuel/Zotero/storage/ASLFI43Q/Watt - 2018 - Mechanising and verifying the WebAssembly specification.pdf:application/pdf},
}

@inproceedings{wallentowitz_potential_2022,
	title = {Potential of {WebAssembly} for {Embedded} {Systems}},
	url = {https://ieeexplore.ieee.org/document/9797106/?arnumber=9797106},
	doi = {10.1109/MECO55406.2022.9797106},
	abstract = {Application virtual machines provide strong isolation properties and are established in the context of software portability. Those opportunities make them interesting for scalable and secure IoT deployments. WebAssembly is an application virtual machine with origins in web browsers, that is getting rapidly adopted in other domains. The strong and steadily growing ecosystem makes WebAssembly an interesting candidate for Embedded Systems. This position paper discusses the usage of WebAssembly in Embedded Systems. After introducing the basic concepts of WebAssembly and existing runtime environments, we give an overview of the challenges for the efficient usage of WebAssembly in Embedded Systems. The paper concludes with a real world case study that demonstrates the viability, before giving an outlook on open issues and upcoming work.},
	urldate = {2025-01-18},
	booktitle = {2022 11th {Mediterranean} {Conference} on {Embedded} {Computing} ({MECO})},
	author = {Wallentowitz, Stefan and Kersting, Bastian and Dumitriu, Dan Mihai},
	month = jun,
	year = {2022},
	note = {ISSN: 2637-9511},
	keywords = {Browsers, Virtual machining, Ecosystems, Embedded computing, embedded systems, interpreter, portability, runtime, Runtime environment, Software, webassembly},
	pages = {1--4},
	file = {Full Text PDF:/home/emanuel/Zotero/storage/MTF2ZYUQ/Wallentowitz et al. - 2022 - Potential of WebAssembly for Embedded Systems.pdf:application/pdf;IEEE Xplore Abstract Record:/home/emanuel/Zotero/storage/3AR6PUKX/9797106.html:text/html},
}

@inproceedings{romano_empirical_2021,
	title = {An {Empirical} {Study} of {Bugs} in {WebAssembly} {Compilers}},
	url = {https://ieeexplore.ieee.org/document/9678776/?arnumber=9678776},
	doi = {10.1109/ASE51524.2021.9678776},
	abstract = {WebAssembly is the newest programming language for the Web. It defines a portable bytecode format for use as a compilation target for programs developed in high-level languages such as C, C++, and Rust. As a result, WebAssembly binaries are generally created by WebAssembly compilers rather than being written manually. To port native code to the Web, WebAssembly compilers need to address the differences between the source and target languages and dissimilarities in their execution environments. A deep understanding of the bugs in WebAssembly compilers can help compiler developers determine where to focus development and testing efforts. In this paper, we conduct two empirical studies to understand the characteristics of the bugs found in WebAssembly compilers. First, we perform a qualitative analysis of bugs in Emscripten, the most widely-used WebAssembly compiler. We investigate 146 bug reports in Emscripten related to the unique challenges WebAssembly compilers encounter compared with traditional compilers. Second, we provide a quantitative analysis of 1,054 bugs in three open-source WebAssembly compilers, AssemblyScript, Emscripten, and Rustc/Wasm-Bindgen. We analyze these bugs along three dimensions: lifecycle, impact, and sizes of bug-inducing inputs and bug fixes. These studies deepen our understanding of WebAssembly compiler bugs. We hope that the findings of our study will shed light on opportunities to design practical tools for testing and debugging WebAssembly compilers.},
	urldate = {2025-01-18},
	booktitle = {2021 36th {IEEE}/{ACM} {International} {Conference} on {Automated} {Software} {Engineering} ({ASE})},
	author = {Romano, Alan and Liu, Xinyue and Kwon, Yonghwi and Wang, Weihang},
	month = nov,
	year = {2021},
	note = {ISSN: 2643-1572},
	keywords = {Codes, WebAssembly, C++ languages, compiler, Computer bugs, Debugging, High level languages, Ports (computers), qualitative study, quantitative study, Statistical analysis},
	pages = {42--54},
	file = {Full Text PDF:/home/emanuel/Zotero/storage/NEJXJTAC/Romano et al. - 2021 - An Empirical Study of Bugs in WebAssembly Compilers.pdf:application/pdf;IEEE Xplore Abstract Record:/home/emanuel/Zotero/storage/FDHYGHMV/9678776.html:text/html},
}

@inproceedings{de_macedo_runtime_2021,
	title = {On the {Runtime} and {Energy} {Performance} of {WebAssembly}: {Is} {WebAssembly} superior to {JavaScript} yet?},
	shorttitle = {On the {Runtime} and {Energy} {Performance} of {WebAssembly}},
	url = {https://ieeexplore.ieee.org/document/9680302/?arnumber=9680302},
	doi = {10.1109/ASEW52652.2021.00056},
	abstract = {In the early days of the world wide web, browsers were developed to navigate through (static) HTML web page documents. This has changed dramatically, and nowadays web pages are dynamic, expressed by programs written in regular programming languages. As a result, browsers are almost operating systems, having to interpret/compile such programs and execute them within the browser itself. Currently, while JavaScript is the main de facto language to express web pages, it does have various short comings and performance inefficiencies. WebAssembly, a new portable and size/load efficient alternative developed by major IT powerhouses, is seen as the future substitute. As WebAssembly aims to be more performance efficient than JavaScript, we aim to look at this current status and present a preliminary study on the performance of these two, based on their runtime and energy efficiency. Preliminary results show that WebAssembly, while still in its infancy, is starting to already challenge JavaScript, with much more room to grow. Additionally, our benchmarking framework is also made available to allow further research and replication.},
	urldate = {2025-01-18},
	booktitle = {2021 36th {IEEE}/{ACM} {International} {Conference} on {Automated} {Software} {Engineering} {Workshops} ({ASEW})},
	author = {De Macedo, Jo√£o and Abreu, Rui and Pereira, Rui and Saraiva, Jo√£o},
	month = nov,
	year = {2021},
	note = {ISSN: 2151-0830},
	keywords = {Operating systems, WebAssembly, Software, Conferences, Energy efficiency, Energy Efficiency, Green Software, Navigation, Runtime, Web Browsers, Web pages},
	pages = {255--262},
	file = {Full Text PDF:/home/emanuel/Zotero/storage/RL4VDHX4/De Macedo et al. - 2021 - On the Runtime and Energy Performance of WebAssembly Is WebAssembly superior to JavaScript yet.pdf:application/pdf;IEEE Xplore Abstract Record:/home/emanuel/Zotero/storage/VIMRX9WK/9680302.html:text/html},
}

@inproceedings{kim_avengers_2022,
	title = {Avengers, {Assemble}! {Survey} of {WebAssembly} {Security} {Solutions}},
	url = {https://ieeexplore.ieee.org/document/9860829/?arnumber=9860829},
	doi = {10.1109/CLOUD55607.2022.00077},
	abstract = {WebAssembly, abbreviated as Wasm, has emerged as a new paradigm in cloud-native developments owing to its promising properties. Native execution speed and fast startup time make Wasm an alternative for container-based cloud applications. Despite its security-by-design strategy, however, WebAssembly suffers from a variety of vulnerabilities and weaknesses, which hinder its rapid adoption in cloud computing. For instance, the native execution performance attracted cybercriminals to abuse Wasm binaries for the purpose of resource stealing such as cryptojacking. Without proper defense mechanisms, Wasm-based malware would proliferate, causing huge financial loss of cloud users. Moreover, the design principle that allows type-unsafe languages such as C/C++ inherently induces various memory bugs in an Wasm binary. Efficient and robust vulnerability analysis techniques are necessary to protect benign cloud-native Wasm applications from being exploited by attackers. Due to the young age of WebAssembly, however, there are few works in the literature that provide developers guidance to such security techniques. This makes developers to hesitate considering Wasm as their cloud-native platform. In this paper, we surveyed various techniques and methods for Wasm binary security proposed in the literature and systematically classified them according to certain criteria. As a result, we propose future research directions regarding the current lack of WebAssembly binary security research.},
	urldate = {2025-01-18},
	booktitle = {2022 {IEEE} 15th {International} {Conference} on {Cloud} {Computing} ({CLOUD})},
	author = {Kim, Minseo and Jang, Hyerean and Shin, Youngjoo},
	month = jul,
	year = {2022},
	note = {ISSN: 2159-6190},
	keywords = {Computer bugs, Cloud computing, Cloud computing security, Malware, Security, Taxonomy, WebAssembly binary security, WebAssembly security solutions},
	pages = {543--553},
	file = {Full Text PDF:/home/emanuel/Zotero/storage/9TRJZQ6P/Kim et al. - 2022 - Avengers, Assemble! Survey of WebAssembly Security Solutions.pdf:application/pdf;IEEE Xplore Abstract Record:/home/emanuel/Zotero/storage/ES6PATSZ/9860829.html:text/html},
}

@inproceedings{de_macedo_webassembly_2022,
	title = {{WebAssembly} versus {JavaScript}: {Energy} and {Runtime} {Performance}},
	shorttitle = {{WebAssembly} versus {JavaScript}},
	url = {https://ieeexplore.ieee.org/document/9830108/?arnumber=9830108},
	doi = {10.1109/ICT4S55073.2022.00014},
	abstract = {The worldwide Web has dramatically evolved in recent years. Web pages are dynamic, expressed by programs written in common programming languages given rise to sophisticated Web applications. Thus, Web browsers are almost operating systems, having to interpret/compile such programs and execute them. Although JavaScript is widely used to express dynamic Web pages, it has several shortcomings and performance inefficiencies. To overcome such limitations, major IT powerhouses are developing a new portable and size/load efficient language: WebAssembly.In this paper, we conduct the first systematic study on the energy and run-time performance of WebAssembly and JavaScript on the Web. We used micro-benchmarks and also real applications in order to have more realistic results. Preliminary results show that WebAssembly, while still in its infancy, is starting to already outperform JavaScript, with much more room to grow. A statistical analysis indicates that WebAssembly produces significant performance differences compared to JavaScript. However, these differences differ between micro-benchmarks and real-world benchmarks. Our results also show that WebAssembly improved energy efficiency by 30\%, on average, and showed how different WebAssembly behaviour is among three popular Web Browsers: Google Chrome, Microsoft Edge, and Mozilla Firefox. Our findings indicate that WebAssembly is faster than JavaScript and even more energy-efficient. Additionally, our benchmarking framework is also available to allow further research and replication.},
	urldate = {2025-01-18},
	booktitle = {2022 {International} {Conference} on {ICT} for {Sustainability} ({ICT4S})},
	author = {De Macedo, Jo√£o and Abreu, Rui and Pereira, Rui and Saraiva, Jo√£o},
	month = jun,
	year = {2022},
	keywords = {Operating systems, WebAssembly, Statistical analysis, Energy efficiency, Energy Efficiency, Green Software, Runtime, Web Browsers, Web pages, Benchmark testing, Systematics},
	pages = {24--34},
	file = {Full Text PDF:/home/emanuel/Zotero/storage/UWXFR859/De Macedo et al. - 2022 - WebAssembly versus JavaScript Energy and Runtime Performance.pdf:application/pdf;IEEE Xplore Abstract Record:/home/emanuel/Zotero/storage/3Q8PPVPR/9830108.html:text/html},
}

@inproceedings{hilbig_empirical_2021,
	address = {Ljubljana Slovenia},
	title = {An {Empirical} {Study} of {Real}-{World} {WebAssembly} {Binaries}: {Security}, {Languages}, {Use} {Cases}},
	isbn = {978-1-4503-8312-7},
	shorttitle = {An {Empirical} {Study} of {Real}-{World} {WebAssembly} {Binaries}},
	url = {https://dl.acm.org/doi/10.1145/3442381.3450138},
	doi = {10.1145/3442381.3450138},
	abstract = {WebAssembly has emerged as a low-level language for the web and beyond. Despite its popularity in different domains, little is known about WebAssembly binaries that occur in the wild. This paper presents a comprehensive empirical study of 8,461 unique WebAssembly binaries gathered from a wide range of sources, including source code repositories, package managers, and live websites. We study the security properties, source languages, and use cases of the binaries and how they influence the security of the WebAssembly ecosystem. Our findings update some previously held assumptions about real-world WebAssembly and highlight problems that call for future research. For example, we show that vulnerabilities that propagate from insecure source languages potentially affect a wide range of binaries (e.g., two thirds of the binaries are compiled from memory unsafe languages, such as C and C++) and that 21\% of all binaries import potentially dangerous APIs from their host environment. We also show that cryptomining, which once accounted for the majority of all WebAssembly code, has been marginalized (less than 1\% of all binaries found on the web) and gives way to a diverse set of use cases. Finally, 29\% of all binaries on the web are minified, calling for techniques to decompile and reverse engineer WebAssembly. Overall, our results show that WebAssembly has left its infancy and is growing up into a language that powers a diverse ecosystem, with new challenges and opportunities for security researchers and practitioners. Besides these insights, we also share the dataset underlying our study, which is 58 times larger than the largest previously reported benchmark.},
	language = {en},
	urldate = {2025-01-19},
	booktitle = {Proceedings of the {Web} {Conference} 2021},
	publisher = {ACM},
	author = {Hilbig, Aaron and Lehmann, Daniel and Pradel, Michael},
	month = apr,
	year = {2021},
	pages = {2696--2708},
	file = {PDF:/home/emanuel/Zotero/storage/N9NGUCJM/Hilbig et al. - 2021 - An Empirical Study of Real-World WebAssembly Binaries Security, Languages, Use Cases.pdf:application/pdf},
}

@inproceedings{van_hasselt_comparing_2022,
	address = {Gothenburg Sweden},
	title = {Comparing the {Energy} {Efficiency} of {WebAssembly} and {JavaScript} in {Web} {Applications} on {Android} {Mobile} {Devices}},
	isbn = {978-1-4503-9613-4},
	url = {https://dl.acm.org/doi/10.1145/3530019.3530034},
	doi = {10.1145/3530019.3530034},
	abstract = {Context. WebAssembly was created as an alternative to JavaScript for developing heavy loading web applications. Since JavaScript is known to have long execution times. A lot of research is already performed to compare the run-time performance of WebAssembly against that of JavaScript. However, little research is available that compares the energy consumption of WebAssembly versus JavaScript. Goal. With this study we aim to identify the correlation between the energy consumption and the use of WebAssembly versus JavaScript. This will aid developers in deciding which method matches the needs of their project best in terms of energy efficiency. Method. The subjects of the experiment are WebAssembly and JavaScript. During the experiment two research questions are defined. For the first research question the programming language is the independent variable. For the second research question the web browser is the independent variable. For both research questions is the energy consumption of the Android device in Joules the dependent variable. Results. We can confirm that the energy consumption of WebAssembly is less than that of JavaScript. The browser also plays a role since the energy consumption of Firefox is significantly smaller than that of Chrome for both WebAssembly and JavaScript. Conclusions. This study provides evidence that using WebAssembly for the development of web applications can reduce the energy consumption and thus improve the battery life of a user‚Äôs Android device. Developers can use this information when choosing a programming language to develop a web application. Moreover, using Firefox over Chrome does also reduce the energy consumption of web applications developed both with WebAssembly and JavaScript.},
	language = {en},
	urldate = {2025-01-19},
	booktitle = {The {International} {Conference} on {Evaluation} and {Assessment} in {Software} {Engineering} 2022},
	publisher = {ACM},
	author = {Van Hasselt, Max and Huijzendveld, Kevin and Noort, Nienke and De Ruijter, Sasja and Islam, Tanjina and Malavolta, Ivano},
	month = jun,
	year = {2022},
	pages = {140--149},
	file = {PDF:/home/emanuel/Zotero/storage/QHXNW2N2/Van Hasselt et al. - 2022 - Comparing the Energy Efficiency of WebAssembly and JavaScript in Web Applications on Android Mobile.pdf:application/pdf},
}

@misc{jangda_not_2019,
	title = {Not {So} {Fast}: {Analyzing} the {Performance} of {WebAssembly} vs. {Native} {Code}},
	shorttitle = {Not {So} {Fast}},
	url = {http://arxiv.org/abs/1901.09056},
	doi = {10.5555/3358807.3358817},
	abstract = {All major web browsers now support WebAssembly, a lowlevel bytecode intended to serve as a compilation target for code written in languages like C and C++. A key goal of WebAssembly is performance parity with native code; previous work reports near parity, with many applications compiled to WebAssembly running on average 10\% slower than native code. However, this evaluation was limited to a suite of scientiÔ¨Åc kernels, each consisting of roughly 100 lines of code. Running more substantial applications was not possible because compiling code to WebAssembly is only part of the puzzle: standard Unix APIs are not available in the web browser environment. To address this challenge, we build BROWSIX-WASM, a signiÔ¨Åcant extension to BROWSIX [22] that, for the Ô¨Årst time, makes it possible to run unmodiÔ¨Åed WebAssembly-compiled Unix applications directly inside the browser. We then use BROWSIX-WASM to conduct the Ô¨Årst large-scale evaluation of the performance of WebAssembly vs. native. Across the SPEC CPU suite of benchmarks, we Ô¨Ånd a substantial performance gap: applications compiled to WebAssembly run slower by an average of 50\% (Firefox) to 89\% (Chrome), with peak slowdowns of 2.6√ó (Firefox) and 3.14√ó Chrome). We identify the causes of this performance degradation, some of which are due to missing optimizations and code generation issues, while others are inherent to the WebAssembly platform.},
	language = {en},
	urldate = {2025-01-19},
	author = {Jangda, Abhinav and Powers, Bobby and Berger, Emery and Guha, Arjun},
	month = may,
	year = {2019},
	note = {arXiv:1901.09056 [cs]},
	keywords = {Computer Science - Programming Languages},
	annote = {Comment: Accepted (to appear) at USENIX Annual Technical Conference 2019},
	file = {PDF:/home/emanuel/Zotero/storage/HUGH74YN/Jangda et al. - 2019 - Not So Fast Analyzing the Performance of WebAssembly vs. Native Code.pdf:application/pdf},
}

@inproceedings{tushar_comparative_2022,
	title = {Comparative {Analysis} {Of} {JavaScript} {And} {WebAssembly} {In} {The} {Browser} {Environment}},
	url = {https://ieeexplore.ieee.org/document/9929829/?arnumber=9929829&tag=1},
	doi = {10.1109/R10-HTC54060.2022.9929829},
	abstract = {As World Wide Web is evolving, larger and high-performance applications are being entirely run on the browsers. Web applications have their own advantages like they are more accessible and platform independent. JavaScript was the only programming-language which was historically supported to be ran on the web browsers, but it is quite limited to high-performance applications as it is dynamically-typed and interpreted language. So, as the high-performance applications started to come to web there have been always a need for another language which could run in the browser environment but also take advantage of system resources. WebAssembly was one such effort by the vendors of different browsers coming together. WebAssembly is claimed to be portable and size and time efficient binary format which could be compiled to run on the web browsers at near native speed. This paper will try to verify the claim by running various experiments on both WebAssembly and JavaScript and measuring resource used and time taken by those programs to execute and will later do a comparative analysis between the both.},
	urldate = {2025-01-19},
	booktitle = {2022 {IEEE} 10th {Region} 10 {Humanitarian} {Technology} {Conference} ({R10}-{HTC})},
	author = {{Tushar} and Mohan, Biju R},
	month = sep,
	year = {2022},
	note = {ISSN: 2572-7621},
	keywords = {Codes, JavaScript, WebAssembly, Browsers, Time measurement, compilation targets, Internet, Maintenance engineering, Memory modules, Performance gain, v8 engine, wasm},
	pages = {232--237},
	file = {Full Text PDF:/home/emanuel/Zotero/storage/FCEAJ3FB/Tushar and Mohan - 2022 - Comparative Analysis Of JavaScript And WebAssembly In The Browser Environment.pdf:application/pdf;IEEE Xplore Abstract Record:/home/emanuel/Zotero/storage/F5DKZCL5/9929829.html:text/html},
}

@article{herrera_webassembly_nodate,
	title = {{WebAssembly} and {JavaScript} {Challenge}: {Numerical} program performance using modern browser technologies and devices},
	language = {en},
	author = {Herrera, David and Chen, Hanfeng and Lavoie, Erick and Hendren, Laurie},
	file = {PDF:/home/emanuel/Zotero/storage/AGIJMX3Q/Herrera et al. - WebAssembly and JavaScript Challenge Numerical program performance using modern browser technologie.pdf:application/pdf},
}

@inproceedings{oliveira_analysis_2020,
	address = {Brasil},
	title = {Analysis of {WebAssembly} as a {Strategy} to {Improve} {JavaScript} {Performance} on {IoT} {Environments}},
	url = {https://sol.sbc.org.br/index.php/sbesc_estendido/article/view/13102},
	doi = {10.5753/sbesc_estendido.2020.13102},
	abstract = {JavaScript language (JS) has been widely used in recent years applied to browsers-context. Yet JS is being applied to other backgrounds such as server-side programming, mobile applications, games, robotics, and the Internet of Things (IoT). JavaScript is suitable for programming IoT devices due to eventdriven oriented architecture. However, it is an interpreted language, so it has a lower performance than a compiled language. This paper assesses the use of WebAssembly as a strategy to improve the performance of JavaScript applications in the IoT environment. The experiments were performed on a Raspberry Pi using the Ostrich Benchmark Suite. We run the algorithms in JavaScript, WebAssembly, and C language while collecting data about device resource consumption. Our results showed that JavaScript performance could be improved by 39.81\% in terms of execution time, a tiny gain in memory usage, and reduced battery consumption by 39.86\% when using WebAssembly.},
	language = {en},
	urldate = {2025-04-22},
	booktitle = {Anais {Estendidos} do {X} {Simp√≥sio} {Brasileiro} de {Engenharia} de {Sistemas} {Computacionais} ({SBESC} {Estendido} 2020)},
	publisher = {Sociedade Brasileira de Computa√ß√£o - SBC},
	author = {Oliveira, Fernando and Mattos, J√∫lio},
	month = nov,
	year = {2020},
	pages = {133--138},
	file = {PDF:/home/emanuel/Zotero/storage/HXGVPNH5/Oliveira and Mattos - 2020 - Analysis of WebAssembly as a Strategy to Improve JavaScript Performance on IoT Environments.pdf:application/pdf},
}

@article{lehmann_everything_nodate,
	title = {Everything {Old} is {New} {Again}: {Binary} {Security} of {WebAssembly}},
	abstract = {WebAssembly is an increasingly popular compilation target designed to run code in browsers and on other platforms safely and securely, by strictly separating code and data, enforcing types, and limiting indirect control Ô¨Çow. Still, vulnerabilities in memory-unsafe source languages can translate to vulnerabilities in WebAssembly binaries. In this paper, we analyze to what extent vulnerabilities are exploitable in WebAssembly binaries, and how this compares to native code. We Ô¨Ånd that many classic vulnerabilities which, due to common mitigations, are no longer exploitable in native binaries, are completely exposed in WebAssembly. Moreover, WebAssembly enables unique attacks, such as overwriting supposedly constant data or manipulating the heap using a stack overÔ¨Çow. We present a set of attack primitives that enable an attacker (i) to write arbitrary memory, (ii) to overwrite sensitive data, and (iii) to trigger unexpected behavior by diverting control Ô¨Çow or manipulating the host environment. We provide a set of vulnerable proof-of-concept applications along with complete end-to-end exploits, which cover three WebAssembly platforms. An empirical risk assessment on real-world binaries and SPEC CPU programs compiled to WebAssembly shows that our attack primitives are likely to be feasible in practice. Overall, our Ô¨Åndings show a perhaps surprising lack of binary security in WebAssembly. We discuss potential protection mechanisms to mitigate the resulting risks.},
	language = {en},
	author = {Lehmann, Daniel},
	file = {PDF:/home/emanuel/Zotero/storage/3SGMMTQE/Lehmann - Everything Old is New Again Binary Security of WebAssembly.pdf:application/pdf},
}
